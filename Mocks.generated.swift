//
//  Mocks.generated.swift
//  UnitTestSwiftCourse
//
//  Generated by Mockingbird v0.20.0.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import UnitTestSwiftCourse
import Foundation
import Swift
import UIKit

private let mkbGenericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked Add
public final class AddMock: UnitTestSwiftCourse.Add, Mockingbird.Mock {
  typealias MockingbirdSupertype = UnitTestSwiftCourse.Add
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "UnitTestSwiftCourse"])

  public enum InitializerProxy {
    public static func initialize(`validNumber`: UnitTestSwiftCourse.ValidNumber, __file: StaticString = #file, __line: UInt = #line) -> AddMock {
      let mock: AddMock = AddMock(validNumber: `validNumber`)
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked validNumber
  override public var `validNumber`: UnitTestSwiftCourse.ValidNumber {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "validNumber.getter", setterSelectorName: "validNumber.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((UnitTestSwiftCourse.ValidNumber).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> UnitTestSwiftCourse.ValidNumber { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as UnitTestSwiftCourse.ValidNumber }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`validNumber`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: UnitTestSwiftCourse.ValidNumber = mkbObject.`validNumber`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (UnitTestSwiftCourse.ValidNumber).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "validNumber.setter", setterSelectorName: "validNumber.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (UnitTestSwiftCourse.ValidNumber) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`validNumber` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`validNumber` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getValidNumber() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> UnitTestSwiftCourse.ValidNumber, UnitTestSwiftCourse.ValidNumber> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> UnitTestSwiftCourse.ValidNumber, UnitTestSwiftCourse.ValidNumber>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "validNumber.getter", setterSelectorName: "validNumber.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((UnitTestSwiftCourse.ValidNumber).self)))
  }

  public func setValidNumber(_ newValue: @autoclosure () -> UnitTestSwiftCourse.ValidNumber) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (UnitTestSwiftCourse.ValidNumber) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (UnitTestSwiftCourse.ValidNumber) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "validNumber.setter", setterSelectorName: "validNumber.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked `add`(`a`: Int, `b`: Int)
  public override func `add`(`a`: Int, `b`: Int) -> Int {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`add`(`a`: Int, `b`: Int) -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`a`), Mockingbird.ArgumentMatcher(`b`)], returnType: Swift.ObjectIdentifier((Int).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Int, Int) -> Int { return mkbImpl(`a`, `b`) }
      if let mkbImpl = mkbImpl as? () -> Int { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`add`(a: `a`, b: `b`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Int = mkbObject.`add`(a: `a`, b: `b`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Int).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `add`(`a`: @autoclosure () -> Int, `b`: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`add`(`a`: Int, `b`: Int) -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`a`), Mockingbird.resolve(`b`)], returnType: Swift.ObjectIdentifier((Int).self)))
  }

  // MARK: Mocked init(`validNumber`: UnitTestSwiftCourse.ValidNumber)
  public required override init(`validNumber`: UnitTestSwiftCourse.ValidNumber) {
    super.init(validNumber: `validNumber`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init(`validNumber`: UnitTestSwiftCourse.ValidNumber)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`validNumber`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize(`validNumber`: @autoclosure () -> UnitTestSwiftCourse.ValidNumber) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UnitTestSwiftCourse.ValidNumber) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (UnitTestSwiftCourse.ValidNumber) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init(`validNumber`: UnitTestSwiftCourse.ValidNumber)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`validNumber`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(Add.self).initialize(…)`.
public func mock(_ type: UnitTestSwiftCourse.Add.Type, file: StaticString = #file, line: UInt = #line) -> AddMock.InitializerProxy.Type {
  return AddMock.InitializerProxy.self
}

// MARK: - Mocked AppDelegate
public final class AppDelegateMock: Mockingbird.Mock {
  typealias MockingbirdSupertype = UnitTestSwiftCourse.AppDelegate
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "UnitTestSwiftCourse"])
}

@available(*, unavailable, message: "'AppDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: UnitTestSwiftCourse.AppDelegate.Type, file: StaticString = #file, line: UInt = #line) -> AppDelegateMock {
  fatalError()
}

// MARK: - Mocked Calculator
public final class CalculatorMock: UnitTestSwiftCourse.Calculator, Mockingbird.Mock {
  typealias MockingbirdSupertype = UnitTestSwiftCourse.Calculator
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "UnitTestSwiftCourse"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    self.mockingbirdContext.sourceLocation = sourceLocation
    CalculatorMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `add`(`n1`: Int, `n2`: Int)
  public override func `add`(`n1`: Int, `n2`: Int) -> Int {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`add`(`n1`: Int, `n2`: Int) -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`n1`), Mockingbird.ArgumentMatcher(`n2`)], returnType: Swift.ObjectIdentifier((Int).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Int, Int) -> Int { return mkbImpl(`n1`, `n2`) }
      if let mkbImpl = mkbImpl as? () -> Int { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`add`(n1: `n1`, n2: `n2`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Int = mkbObject.`add`(n1: `n1`, n2: `n2`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Int).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `add`(`n1`: @autoclosure () -> Int, `n2`: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`add`(`n1`: Int, `n2`: Int) -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`n1`), Mockingbird.resolve(`n2`)], returnType: Swift.ObjectIdentifier((Int).self)))
  }

  // MARK: Mocked `divide`(`n1`: Int, `n2`: Int)
  public override func `divide`(`n1`: Int, `n2`: Int) -> Int {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`divide`(`n1`: Int, `n2`: Int) -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`n1`), Mockingbird.ArgumentMatcher(`n2`)], returnType: Swift.ObjectIdentifier((Int).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Int, Int) -> Int { return mkbImpl(`n1`, `n2`) }
      if let mkbImpl = mkbImpl as? () -> Int { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`divide`(n1: `n1`, n2: `n2`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Int = mkbObject.`divide`(n1: `n1`, n2: `n2`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Int).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `divide`(`n1`: @autoclosure () -> Int, `n2`: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`divide`(`n1`: Int, `n2`: Int) -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`n1`), Mockingbird.resolve(`n2`)], returnType: Swift.ObjectIdentifier((Int).self)))
  }

  // MARK: Mocked `divideByZero`(`n1`: Int, `n2`: Int)
  public override func `divideByZero`(`n1`: Int, `n2`: Int) throws -> Int {
    return try self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`divideByZero`(`n1`: Int, `n2`: Int) throws -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`n1`), Mockingbird.ArgumentMatcher(`n2`)], returnType: Swift.ObjectIdentifier((Int).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Int, Int) throws -> Int { return try mkbImpl(`n1`, `n2`) }
      if let mkbImpl = mkbImpl as? () throws -> Int { return try mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return try super.`divideByZero`(n1: `n1`, n2: `n2`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Int = try mkbObject.`divideByZero`(n1: `n1`, n2: `n2`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Int).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `divideByZero`(`n1`: @autoclosure () -> Int, `n2`: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (Int, Int) throws -> Int, Int> {
    return Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (Int, Int) throws -> Int, Int>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`divideByZero`(`n1`: Int, `n2`: Int) throws -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`n1`), Mockingbird.resolve(`n2`)], returnType: Swift.ObjectIdentifier((Int).self)))
  }

  // MARK: Mocked `subtract`(`n1`: Int, `n2`: Int)
  public override func `subtract`(`n1`: Int, `n2`: Int) -> Int {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`subtract`(`n1`: Int, `n2`: Int) -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`n1`), Mockingbird.ArgumentMatcher(`n2`)], returnType: Swift.ObjectIdentifier((Int).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Int, Int) -> Int { return mkbImpl(`n1`, `n2`) }
      if let mkbImpl = mkbImpl as? () -> Int { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`subtract`(n1: `n1`, n2: `n2`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Int = mkbObject.`subtract`(n1: `n1`, n2: `n2`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Int).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `subtract`(`n1`: @autoclosure () -> Int, `n2`: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int, Int) -> Int, Int>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`subtract`(`n1`: Int, `n2`: Int) -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`n1`), Mockingbird.resolve(`n2`)], returnType: Swift.ObjectIdentifier((Int).self)))
  }

  // MARK: Mocked `myArray`(`arrayInt`: [Int])
  public override func `myArray`(`arrayInt`: [Int]) -> [Int] {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`myArray`(`arrayInt`: [Int]) -> [Int]", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`arrayInt`)], returnType: Swift.ObjectIdentifier(([Int]).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? ([Int]) -> [Int] { return mkbImpl(`arrayInt`) }
      if let mkbImpl = mkbImpl as? () -> [Int] { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`myArray`(arrayInt: `arrayInt`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: [Int] = mkbObject.`myArray`(arrayInt: `arrayInt`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: ([Int]).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `myArray`(`arrayInt`: @autoclosure () -> [Int]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Int]) -> [Int], [Int]> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Int]) -> [Int], [Int]>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`myArray`(`arrayInt`: [Int]) -> [Int]", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`arrayInt`)], returnType: Swift.ObjectIdentifier(([Int]).self)))
  }

  // MARK: Mocked `arraySquared`(`numberArray`: [Int])
  public override func `arraySquared`(`numberArray`: [Int]) -> [Int] {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`arraySquared`(`numberArray`: [Int]) -> [Int]", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`numberArray`)], returnType: Swift.ObjectIdentifier(([Int]).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? ([Int]) -> [Int] { return mkbImpl(`numberArray`) }
      if let mkbImpl = mkbImpl as? () -> [Int] { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`arraySquared`(numberArray: `numberArray`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: [Int] = mkbObject.`arraySquared`(numberArray: `numberArray`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: ([Int]).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `arraySquared`(`numberArray`: @autoclosure () -> [Int]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Int]) -> [Int], [Int]> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Int]) -> [Int], [Int]>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`arraySquared`(`numberArray`: [Int]) -> [Int]", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`numberArray`)], returnType: Swift.ObjectIdentifier(([Int]).self)))
  }

  // MARK: Mocked `arraySquared2`(`numberArray`: [Int])
  public override func `arraySquared2`(`numberArray`: [Int]) -> [Int] {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`arraySquared2`(`numberArray`: [Int]) -> [Int]", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`numberArray`)], returnType: Swift.ObjectIdentifier(([Int]).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? ([Int]) -> [Int] { return mkbImpl(`numberArray`) }
      if let mkbImpl = mkbImpl as? () -> [Int] { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`arraySquared2`(numberArray: `numberArray`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: [Int] = mkbObject.`arraySquared2`(numberArray: `numberArray`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: ([Int]).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `arraySquared2`(`numberArray`: @autoclosure () -> [Int]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Int]) -> [Int], [Int]> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Int]) -> [Int], [Int]>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`arraySquared2`(`numberArray`: [Int]) -> [Int]", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`numberArray`)], returnType: Swift.ObjectIdentifier(([Int]).self)))
  }
}

/// Returns a concrete mock of `Calculator`.
public func mock(_ type: UnitTestSwiftCourse.Calculator.Type, file: StaticString = #file, line: UInt = #line) -> CalculatorMock {
  return CalculatorMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked SceneDelegate
public final class SceneDelegateMock: Mockingbird.Mock {
  typealias MockingbirdSupertype = UnitTestSwiftCourse.SceneDelegate
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "UnitTestSwiftCourse"])
}

@available(*, unavailable, message: "'SceneDelegate' does not declare any accessible designated initializers and cannot be mocked")
public func mock(_ type: UnitTestSwiftCourse.SceneDelegate.Type, file: StaticString = #file, line: UInt = #line) -> SceneDelegateMock {
  fatalError()
}

// MARK: - Mocked StringManager
public final class StringManagerMock: UnitTestSwiftCourse.StringManager, Mockingbird.Mock {
  typealias MockingbirdSupertype = UnitTestSwiftCourse.StringManager
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "UnitTestSwiftCourse"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    self.mockingbirdContext.sourceLocation = sourceLocation
    StringManagerMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `toLowerCased`(`message`: String)
  public override func `toLowerCased`(`message`: String) -> String {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`toLowerCased`(`message`: String) -> String", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`message`)], returnType: Swift.ObjectIdentifier((String).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String) -> String { return mkbImpl(`message`) }
      if let mkbImpl = mkbImpl as? () -> String { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`toLowerCased`(message: `message`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: String = mkbObject.`toLowerCased`(message: `message`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `toLowerCased`(`message`: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`toLowerCased`(`message`: String) -> String", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`message`)], returnType: Swift.ObjectIdentifier((String).self)))
  }

  // MARK: Mocked `toUpperCased`(`message`: String)
  public override func `toUpperCased`(`message`: String) -> String {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`toUpperCased`(`message`: String) -> String", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`message`)], returnType: Swift.ObjectIdentifier((String).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String) -> String { return mkbImpl(`message`) }
      if let mkbImpl = mkbImpl as? () -> String { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`toUpperCased`(message: `message`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: String = mkbObject.`toUpperCased`(message: `message`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `toUpperCased`(`message`: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`toUpperCased`(`message`: String) -> String", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`message`)], returnType: Swift.ObjectIdentifier((String).self)))
  }
}

/// Returns a concrete mock of `StringManager`.
public func mock(_ type: UnitTestSwiftCourse.StringManager.Type, file: StaticString = #file, line: UInt = #line) -> StringManagerMock {
  return StringManagerMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ValidNumber
public final class ValidNumberMock: UnitTestSwiftCourse.ValidNumber, Mockingbird.Mock {
  typealias MockingbirdSupertype = UnitTestSwiftCourse.ValidNumber
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "UnitTestSwiftCourse"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    self.mockingbirdContext.sourceLocation = sourceLocation
    ValidNumberMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `check`(`num`: Int)
  public override func `check`(`num`: Int) -> Bool {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`check`(`num`: Int) -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`num`)], returnType: Swift.ObjectIdentifier((Bool).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Int) -> Bool { return mkbImpl(`num`) }
      if let mkbImpl = mkbImpl as? () -> Bool { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`check`(num: `num`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Bool = mkbObject.`check`(num: `num`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Bool).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `check`(`num`: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Bool, Bool> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> Bool, Bool>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`check`(`num`: Int) -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`num`)], returnType: Swift.ObjectIdentifier((Bool).self)))
  }
}

/// Returns a concrete mock of `ValidNumber`.
public func mock(_ type: UnitTestSwiftCourse.ValidNumber.Type, file: StaticString = #file, line: UInt = #line) -> ValidNumberMock {
  return ValidNumberMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ViewController
public final class ViewControllerMock: UnitTestSwiftCourse.ViewController, Mockingbird.Mock {
  typealias MockingbirdSupertype = UnitTestSwiftCourse.ViewController
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "UnitTestSwiftCourse"])

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> ViewControllerMock? {
      let mock: ViewControllerMock? = ViewControllerMock(coder: `coder`)
      mock?.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(nibName `nibNameOrNil`: String?, bundle `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> ViewControllerMock {
      let mock: ViewControllerMock = ViewControllerMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `viewDidLoad`()
  public override func `viewDidLoad`() -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`viewDidLoad`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`viewDidLoad`()
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`viewDidLoad`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `viewDidLoad`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`viewDidLoad`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked init?(`coder`: NSCoder)
  public required init?(`coder`: NSCoder) {
    super.init(coder: `coder`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init?(`coder`: NSCoder)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`coder`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize(`coder`: @autoclosure () -> NSCoder) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (NSCoder) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (NSCoder) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init?(`coder`: NSCoder)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`coder`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked init(nibName `nibNameOrNil`: String?, bundle `nibBundleOrNil`: Bundle?)
  public required override init(nibName `nibNameOrNil`: String?, bundle `nibBundleOrNil`: Bundle?) {
    super.init(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init(nibName `nibNameOrNil`: String?, bundle `nibBundleOrNil`: Bundle?)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`nibNameOrNil`), Mockingbird.ArgumentMatcher(`nibBundleOrNil`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize(nibName `nibNameOrNil`: @autoclosure () -> String?, bundle `nibBundleOrNil`: @autoclosure () -> Bundle?) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String?, Bundle?) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String?, Bundle?) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init(nibName `nibNameOrNil`: String?, bundle `nibBundleOrNil`: Bundle?)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`nibNameOrNil`), Mockingbird.resolve(`nibBundleOrNil`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(ViewController.self).initialize(…)`.
public func mock(_ type: UnitTestSwiftCourse.ViewController.Type, file: StaticString = #file, line: UInt = #line) -> ViewControllerMock.InitializerProxy.Type {
  return ViewControllerMock.InitializerProxy.self
}
